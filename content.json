{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"介绍一下我的乖乖~","slug":"介绍一下我的乖乖","date":"2023-03-26T13:44:40.000Z","updated":"2023-03-26T13:47:34.117Z","comments":true,"path":"2023/03/26/介绍一下我的乖乖/","link":"","permalink":"http://example.com/2023/03/26/%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E6%88%91%E7%9A%84%E4%B9%96%E4%B9%96/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"串替换答案","slug":"串替换","date":"2021-04-18T12:58:23.000Z","updated":"2023-03-26T13:36:33.402Z","comments":true,"path":"2021/04/18/串替换/","link":"","permalink":"http://example.com/2021/04/18/%E4%B8%B2%E6%9B%BF%E6%8D%A2/","excerpt":"","text":"由于呢这个题目，我的思路写出来的代码一个测试都通不过，于是乎我上网搜了搜有没有答案，找到了一个还不错的答案，放在末尾。 先上题目 简述一下我的想法 把步骤拆成几步，分别写对应的函数 先找到子串匹配的首尾位置 找到原串的尾位置 计算出新旧交替多出来的字符数x 让原串中子串匹配的尾位置向后推进x个字符(给新旧交替腾出位置) 再把新串从子串匹配的首位置开始复制 最后就形成一个新的改造串 然后用这个改造串代替原串继续循环改造 函数有点多，放在下一篇博客 我上网搜的答案","categories":[],"tags":[]},{"title":"广义表补充","slug":"广义表补充","date":"2021-04-15T12:22:53.000Z","updated":"2023-03-26T13:36:52.181Z","comments":true,"path":"2021/04/15/广义表补充/","link":"","permalink":"http://example.com/2021/04/15/%E5%B9%BF%E4%B9%89%E8%A1%A8%E8%A1%A5%E5%85%85/","excerpt":"","text":"广义表最基本的操作：取表头head(LS)与取表尾tail(LS) head()是取表头元素，即表中第一个元素（可以是表） tail()是取表尾，即原表去掉第一个元素后剩下形成的表。注意：如果LS=(a,b),则tail(LS)=(b),而不是b；tail返回的一定是个表。 例：LS=(a,(b,c,d)) head(LS)=a tail(LS)=((b,c,d)) head(tail(LS))=(b,c,d) tail(tail(LS))=() head(head(tail(LS)))=b tail(head(tail(LS)))=(c,d) head(tail(head(tail(LS))))=c tail(tail(head(tail(LS))))=(d) head(tail(tail(head(tail(LS)))))=d tail(tail(tail(head(tail(LS)))))=()","categories":[],"tags":[]},{"title":"广义表知识点","slug":"广义表知识点","date":"2021-04-15T11:59:53.000Z","updated":"2023-03-26T13:37:19.341Z","comments":true,"path":"2021/04/15/广义表知识点/","link":"","permalink":"http://example.com/2021/04/15/%E5%B9%BF%E4%B9%89%E8%A1%A8%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"广义表是 n 个数据元素（d1，d2，d3，…，dn）的有限序列，广义表中的 di 既可以是单个元素，也可以是一个广义表。 通常记为 L = （d1，d2，d3，…，dn），L 是广义表的名称，通常广义表的名称用大写字母表示。n 是广义表的长度。 若其中的 di 是一个广义表，则称 di 是广义表 L 的子表。 在广义表 L 中，d1 是广义表 L 的表头，而广义表 L 其余部分组成的表（d2，d3，…，dn）称为广义表表尾。 这一点与下面的常用函数有关，先来几个例题。 题目：广义表 L =（a，（b，c））的表头是单个元素 a，表尾是广义表（（b，c）），即head（L）= a ， tail（L）= （（b，c）） 注：求表尾的时候原广义表的最外面这层小括号不能漏，即 tail（L）的结果不是（b，c），而是（（b，c）） 题目：广义表 L =（（a，b），c）的表头不是 a，而是子表（a，b），表尾是广义表（c） 题目：广义表 L =（a，b，c）的表头是单个元素 a，表尾是（b，c） 题目：广义表 L =（a）的表头是单个元素 a，表尾是广义表（），表尾一定是个广义表，表尾为空时则用（）表示 广义表的长度： 广义表的长度指：广义表中所包含的数据元素的个数。题目：在广义表 （a，（b，c，d））中，它包含单个元素 a 和一个子表（b，c，d），因此该广义表的长度为 2 题目：广义表（（a，b，c）） 中只有一个子表（a，b，c），因此该广义表的长度为 1 广义表的深度： 广义表的深度，可以通过观察该表中所包含括号的层数间接得到。这里需要注意，数左括号（或右括号）时同一层次的多个括号只计算一次。 深度的求法为上面每个元素的括号匹配数加1的最大值 题目：广义表（（a，b），（c，（d，e））） 中，子表（a，b） 和 （c，（d，e）） 位于同层，（a，b）只有 1 层括号，而（c，（d，e））有 2 层括号，加上最外层的 1 层括号，所以此广义表中包含 3 层括号，因此深度为 3 题目：广义表 （a，（a，b），d，e，（（i，j），k））的深度是 3 a 的括号匹配数为 0，加上1后为1;（a，b）的括号匹配数为 1，加上1后为2;d 的括号匹配数为 0，加上1后为1;e 的括号匹配数为 0，加上1后为1;（（i，j），k）的括号匹配数为 2，加上1后为3找最大值，故该广义表的深度为3. 待补充","categories":[],"tags":[]},{"title":"树的知识点收录","slug":"树的知识点收录","date":"2021-04-13T08:58:53.000Z","updated":"2023-03-26T13:38:14.560Z","comments":true,"path":"2021/04/13/树的知识点收录/","link":"","permalink":"http://example.com/2021/04/13/%E6%A0%91%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E6%94%B6%E5%BD%95/","excerpt":"","text":"度是一个树中的各个结点拥有的子树最多的个数. 二叉树指的是度小于等于2的数. 空树是指根结点都没有. 由此可见,二叉树的度可以是0,1,2.不一定是2,所以不一样. 遍历树的方式(递归代码) 先序(根,左,右)123456789void PreOrder(Bitree root)&#123; if(root!=NULL) &#123; Visit(root-&gt;data);//访问根结点 PreOrder(root-&gt;LChild);//先序遍历左子树 PreOrder(root-&gt;RChild);//先序遍历右子树 &#125;&#125; 中序(左,根,右)123456789void InOrder(Bitree root)&#123; if(root!=NULL) &#123; InOrder(root-&gt;LChild);//中序访问左子树 Visit(root-&gt;data);//访问根节点 InOrder(root-&gt;RChild);//中序访问右子树 &#125;&#125; 后序(左,右,根)123456789void PostOrder(Bitree root)&#123; if(root!=NULL) &#123; PostOrder(root-&gt;LChild);//后序访问左子树 PostOrder(root-&gt;RChild);//后序序访问右子树 Visit(root-&gt;data);//访问根节点 &#125;&#125; 输出二叉数的结点 和第二点差不多,把里面的Visit(root-&gt;data)换成printf(root-&gt;data)就行 举个例子,先序. 123456789void PreOrder(Bitree root)&#123; if(root!=NULL) &#123; printf(root-&gt;data);//输出根结点 PreOrder(root-&gt;LChild);//先序遍历左子树 PreOrder(root-&gt;RChild);//先序遍历右子树 &#125;&#125;","categories":[],"tags":[]},{"title":"求next数组的算法","slug":"求next数组算法","date":"2021-04-12T09:38:53.000Z","updated":"2023-03-26T13:37:50.379Z","comments":true,"path":"2021/04/12/求next数组算法/","link":"","permalink":"http://example.com/2021/04/12/%E6%B1%82next%E6%95%B0%E7%BB%84%E7%AE%97%E6%B3%95/","excerpt":"","text":"这篇学求next数组算法 话不多说，直接上代码 12345678910111213141516171819202122void GetNext(SString t,int next[]) &#123; int j, k; j=0; k=-1; next[0]=-1; while (j&lt;t.length-1) //因为next数组的赋值都是在j++之后，所以判断条件是j&lt;t.length-1 &#123; if (k==-1 || t.data[j]==t.data[k]) &#123; j++; //推进到下一位 k++;//推进到下一位 next[j]=k; /*更新next数组*/ &#125; else k=next[k]; //next[k]代表的是下标k之前的字符的前缀后缀相同最大值 //所以next[k]也同时代表了字符不匹配时k回溯的位置（有点难理解，可以参考KMP算法的图解，差不多的原理） //回溯到最长相同前缀的后一位（下面会讲为什么） &#125;&#125; 虽然代码很短，但是理解起来十分费劲，不得不佩服前人的智慧，tql。 让我们来说说为什么k=next[k]之后k的位置是最长相同前缀的后一位 next[k]代表的是最长相同前缀的长度,所以最长相同前缀最后一个字符的下标对应就是next[k]-1，因此next[k]就是下一位。 光这么说，还是很难理解，我们上一个例子。 例子 演算过程: 初始:j=0; k=-1; next[0]=-1; 1）j=1; k=0; next[1]=0; 2）t.data[1] t.data[0] 不等 k=next[0]=-1; 3）j=2; k=0; next[2]=0; 4）t.data[2] t.data[0] 不等 k=next[0]=-1; 5）j=3; k=0; next[3]=0; 6）t.data[3] = =t.data[0] 等 j=4; k=1; next[4]=1; 7）t.data[4] = =t.data[1] 等 j=5; k=2; next[5]=2; 这算法确实难理解,再次感叹先人智慧.","categories":[],"tags":[]},{"title":"学习 KMP算法","slug":"KMP算法学习","date":"2021-04-12T09:16:43.000Z","updated":"2023-03-26T13:36:04.649Z","comments":true,"path":"2021/04/12/KMP算法学习/","link":"","permalink":"http://example.com/2021/04/12/KMP%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"KMP算法是模式串匹配一种提高效率的算法 ONE. 为什么这么说呢？ 相比于暴力算法（一个一个对比，不匹配子串回归第一个字符，主串回归原本字符的下一个），暴力算法的时间复杂度是O(m*n),空间复杂度是O(1), m和n分别是子串长度和主串长度。而KMP算法的KMP算法的总时间复杂度为O(m+n)，空间复杂度记为O(m)。空间多用了一点，但效率却大大提升，明显是非常有用的。 至于为啥时间复杂度和空间复杂度是这样，详见下面解析。 TWO. 了解KMP算法之前，我们先来一些知识点铺垫 前缀，后缀分别是什么? 一串子串的前缀就是包括这个子串第一个字符不包括最后一个字串且连续的一段子串。 同理，后缀就是包括这个子串最后一个字符不包括第一个字串且连续的一段子串。 举例，对于abbabc这一段串的前缀和后缀是啥？ 前缀：a,ab,abb,abba,abbab. 后缀：c,bc,abc,babc,bbabc. next数组用于存放子串中每个字符位置前那一段子串的对应的前缀和后缀中相同的缀的最大长度。（next[0]默认为-1） next[i]=j,含义是：下标为i 的字符前的字符串最长相等前后缀的长度为j。 举例 子串t= “abcabcmn”的next数组为next[0]=-1(前面没有字符串单独处理)next[1]=0；next[2]=0；next[3]=0；next[4]=1；next[5]=2；next[6]=3；next[7]=0； THREE. 接下来我们来了解一下KMP的工作原理(用图解的方式) ps. 这个图解我觉得非常棒,很直观. 现在我们先看一个图：第一个长条代表主串，第二个长条代表子串。红色部分代表两串中已匹配的部分，绿色和蓝色部分分别代表主串和子串中不匹配的字符。再具体一些：这个图代表主串”abcabeabcabcmn”和子串”abcabcmn”。 匹配到第六个字符的时候不匹配了,对应的是next[5]=2; 灰色部分就是红色部分字符串的最长相等前后缀，我们子串移动的结果就是让子串的红色部分最长相等前缀和主串红色部分最长相等后缀对齐(即把子串的第一个灰色区域移动到主串的第二个灰色区域下对应) 这就是移动后的结果,配合这个图理解一下,一开始可能不是很好理解. FOUR. 最后我们看一下KMP具体的代码,求next数组的代码放在下一篇博客. 123456789101112131415161718int KMPIndex(SqString s,SqString t) //KMP算法&#123; int next[MaxSize],i=0,j=0; GetNext(t,next);//求next数组的函数 while (i&lt;s.length &amp;&amp; j&lt;t.length) &#123; if (j==-1 || s.data[i]==t.data[j]) &#123; i++;j++; //i,j各增1 &#125; else j=next[j]; //i不变,j后退，现在知道为什么这样让子串回退了吧 &#125; if (j&gt;=t.length) return(i-t.length); //返回匹配模式串的首字符下标 else return(-1); //返回不匹配标志&#125; FIVE. 声明,本博客部分图和代码是参考csdn博主的一篇文章,推荐大家可以去看一下,非常详细.原文链接","categories":[],"tags":[]},{"title":"TuBG's icoding","slug":"icoding problem","date":"2021-04-10T13:12:53.000Z","updated":"2023-03-26T13:35:34.590Z","comments":true,"path":"2021/04/10/icoding problem/","link":"","permalink":"http://example.com/2021/04/10/icoding%20problem/","excerpt":"","text":"分享一波今日icoding的解题思路 先来看一波题目 分析思路 由于函数的参数是字符串，输入的类型就是字符型。也就是我们需要对字符进行分类判断。 识别到空格 空格符号ascii码值为32 由于存贮数字的停止循环条件是判断到空格，所以写if的时候我们可以将判断到空格的情况化到其他两种情况中去。 识别的字符为数字(需要考虑到多位数数字的入栈方式) 0到9对应ascii码值为48~57，所以askii码值-48就是数字大小。 入栈方式：我们可以定义一个整型变量num来存储多位数，然后用一个循环不断识别字符，每次令num=num*10+x(新识别到的数)，最终识别到空格的时候循环停止，此时num的值就是我们要入栈的多位数。 识别到计算符号op 用y和x分别存第一个出栈的数字和第二个出栈的数字，进行x op y的操作，将操作完的结果再次入栈。 接下来是具体的代码和注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; int main()&#123; char a;//a用来存识别到的字符 int x, y,num = 0;//num存储多位数的值，初始化为0 while (((a = *str++)) != &#x27;\\0&#x27;) &#123; //识别到字符串末尾的&#x27;\\0&#x27;的时候表明输入结束 if (a &gt;= 48 &amp;&amp; a &lt;= 57) &#123;//识别到数字的情况 num = a - 48; while (*str != 32) &#123; //识别到空格的时候停止循环 num = num * 10 + (*str - 48);//*str用作整型数值就是ascii码值 str++;//推进到下一个字符 &#125; push(&amp;stack, num);//让num进栈 num = 0;//重新初始化num &#125; else &#123; //识别到计算符号的情况 switch (a) &#123; case &#x27;+&#x27;: &#123; pop(&amp;stack, &amp;y); pop(&amp;stack, &amp;x); push(&amp;stack, x + y); break; &#125; case &#x27;-&#x27;: &#123; pop(&amp;stack, &amp;y); pop(&amp;stack, &amp;x); push(&amp;stack, x - y); break; &#125; case &#x27;*&#x27;: &#123; pop(&amp;stack, &amp;y); pop(&amp;stack, &amp;x); push(&amp;stack, x * y); break; &#125; case &#x27;/&#x27;: &#123; pop(&amp;stack, &amp;y); pop(&amp;stack, &amp;x); push(&amp;stack, x / y); break; &#125; case &#x27;%&#x27;: &#123; pop(&amp;stack, &amp;y); pop(&amp;stack, &amp;x); push(&amp;stack, x % y); break; &#125; &#125; &#125; &#125; pop(&amp;stack, &amp;x);//用x存最后的结果返回x的值 return x;&#125; 总结 我觉得这道题比较难的地方，是如何进行多位数的入栈。 因为我们识别的字符型，一次最多识别一个数字，我们需要的就是如何通过依次识别多位数的各个数字字符求出多位数的值并使其入栈。 其他地方的话相比之下并不是很难。","categories":[],"tags":[]},{"title":"TuBG's first blog","slug":"First-blog","date":"2021-04-07T13:30:53.000Z","updated":"2023-03-26T13:32:36.126Z","comments":true,"path":"2021/04/07/First-blog/","link":"","permalink":"http://example.com/2021/04/07/First-blog/","excerpt":"","text":"兔八哥 兔八哥简介 观看网址","categories":[],"tags":[]}],"categories":[],"tags":[]}